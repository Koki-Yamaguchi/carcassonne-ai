# カルカソンヌ AI の設計
## 概要
大きく分けて 4 つの機能からなる

1. UI (フロントエンド)
2. アプリケーションとして必要な各種機能 (バックエンド)
3. カルカソンヌの手を解釈するインタプリタ (バックエンド)
4. AI (バックエンド)

### 1. UI
AI は可視化して誰でもその手を見れたりそれと対戦できたりできるようにしたい。
そのためにはタイルの配置、得点やミープルの表示、タイルやミープルの移動のアニメーションなどが必要。
タイルの配置は過去の拙作 <https://carcassonne-simulator.web.app/simulator> みたいな感じのを作れば良い。
原則として全ての計算をバックエンドに任せるのでフロントエンドではその描画を頑張る。

### 2. アプリケーションとして必要な各種機能
ユーザーが AI と対戦する上で、そのユーザーが何かしら簡単に認証できるようにしたい。
ユーザーの情報や試合の情報などを読み書きできる API を作る。
将来的には必要に応じて AI に対する勝率や elo rating 的なものや統計情報などもとれるようにするかもしれない。

### 3. インタプリタ
カルカソンヌの合法な手の列を与えるとその意味を解釈するインタプリタをまず作る必要がある。
主にタイルと生成される地形の管理を行なって得点計算を正しく行う。
AI が何度も呼び出す可能性が高いのでできるだけ高速に動くように書く。

### 4. AI
カルカソンヌの合法な手の列を与えるとその次の手を返す AI 本体の実装。
強い AI を作ることが一番他のアプリケーションとの差別化ができるところなので、ここを一番頑張る。


## アプリケーションの詳細
認証済みのユーザーが game を作成することでゲームが開始する。

カルカソンヌの盤面は合法な move の列と一対一で対応する。
move には tile move と meeple move があってそれらが順番に出てくるような列を考える。
tile move にはざっくり { タイルの種類, 回転回数, タイルを置く位置 } のような情報を載せて、 meeple move には { ミープル番号, 直前のタイル対してミープルを置く位置 } を載せる。
例えば初期盤面の手の列は [{ スタートタイル, 0, (0, 0) }, {}] のようになり、最初のプレイヤーがストレートタイルを右につけて道にミープル 0 を置いたときの盤面は [{ スタートタイル, 0, (0, 0) }, {}, { ストレートタイル, 1, (1, 0)}, { 0, 道 }] などと表現されることになる。

ゲームが作成されたら API から次に置くべきタイルがランダムに返ってくるので、そのタイルを含む tile move を決めて API に投げる。その結果としてそのタイル上のミープル配置可能な位置の情報が返ってくるのでそれに応じて meeple move を投げれるようにする。 (tile move と meeple move を分けているのは、ミープルが置ける場所の計算をフロントエンドでやらなくてよいようにするため)

meeple move を投げると events が返ってくるのでそれに応じて描画等する。
events というのは { 回収されるミープルの番号, それによって得られる点数 } みたいな情報の配列。
フロントエンドではその情報を特に解釈する必要はなくただその情報から最低限の更新を行なって、次のターンに遷移する。


## インタプリタ の詳細
カルカソンヌの手の列を解釈するインタプリタの部分

### 言語
主に以下の理由から実装の言語は Rust にした。正解だったと思う。
- 速度を重視したいため Python や Golang などより良い
- バグる可能性のある部分がたくさんでてきそうなので、バグはできるだけコンパイル時に検出させる
- パターンマッチングの表現力が生かせる

### 計算量
時間計算量はタイルの数を N としたときに O(N log N) で実現する。定数倍は大きめ。
雑に実装すると地形のマージの部分などでおそらく O(N^2) になるので注意。
O(N) かそれに近い計算量でやることは可能だと思うので必要になれば頑張る。

### タイルの配置
ナイーブにやると二次元配列を用意してそこにただタイルをのせていくという感じになるのだけど、これだと最後の得点計算のところの時間計算量が O(N^2) になるのが良くない。 (i32, i32) -> Tile みたいなハッシュマップでやると速くなるかと思ったけどあまり変わらなかった。配列のサイズには依存しなくなったので少しましとも言える。改善の余地がある。

### タイルの回転
各タイルに時計回りの (90 度毎の) 回転数 rot を持たせておく。また、例えば右折タイルの各辺が何であるかを右から反時計回りで以下のように定めておく。

```rust
tile.sides = vec![Road, City, Field, Road];
```

このとき例えば右折タイルを rot だけ回転させた後の各辺は以下のようにして取れる

```rust
tile.right_side  = tile.sides[(rot + 0) % 4];
tile.top_side    = tile.sides[(rot + 1) % 4];
tiie left_side   = tile.sides[(rot + 2) % 4];
tile.bottom_side = tile.sides[(rot + 3) % 4];
```

### 地形の管理
道、街、草原、修道院をまとめて地形と呼ぶことにする。タイルが配置されるたびにその新規地形を生成する。
例えば右折タイルでは 街, 街に隣接する草原, 道, もう一つの草原 の 4 つがある。
各地形にはユニークな id をつけておく。

まず各タイルの各側面に出現する地形がわかるようにする必要があって、それはタイルの回転の項で見たようなものと同様にやる。例えば右折タイルの 4 つの地形を上記の順で 0 ~ 3 で id を定めると、地形情報は右から反時計回りで以下のように書ける。

```rust
tile.side_features = vec![
    vec![Feature { id: 1, type: Field }, Feature { id: 2, type: Road }, Feature { id: 3, type: Field } ],
    vec![Feature { id: 0, type: City }],
    vec![Feature { id: 1, type: Field }],
    vec![Feature { id: 3, type: Field }, Feature { id: 2, type: Road }, Feature { id: 1, type: Field } ],
];
```

ここで側面の情報を時計回りでとっておくことに注意する。そうしておくことで取りたい情報が回転の影響を考えずに取ることができる。

これで新しく地形を配置したときにどの地形とどの地形がマージされるのかがわかるようになったので、あとはそのマージの実装をする。

一番ナイーブな実装方法は、グループという概念を用意して、どの地形がどのグループに属するかを更新しながら地形のマージ情報を管理する方法だと思う。地形を生成するタイミングでその地形が属するグループも生成して、マージするときに片方のグループをもう片方のグループに書き換える。

```rust

fn merge(feature0: Feature, feature1: Feature) {
    let group0 = feature0.group;
    let group1 = feature1.group;
    if group0.id == group1.id {
        return;
    }
    feature0.set_group(group1);

    // group0 としてラベル付けされていたその他の地形も group1 に書き換えないといけない
    for feature in group0.features {
        feature.set_group(group1);
        group1.add_feature(feature);
    }
}
```

この実装では上記のコメントアウト以降のグループの書き換え処理の部分があるため、 タイルの総数を N とすると merge を呼ぶたびに計算量が O(N) かかり、マージはタイルをおくたびに必ず 1 回は起こるので全体の時間計算量は O(N^2) になる。

ここで、より一般に集合のグループをマージしたり同一グループ判定したりを高速にできる [素集合データ構造](https://ja.wikipedia.org/wiki/%E7%B4%A0%E9%9B%86%E5%90%88%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0) というものが実はあって、カルカソンヌの地形の管理にぴったりなのでこれを使う。これが何かをざっくり説明するとある二つの要素をマージするという操作をただその要素の間に辺を張ることだけで済ませてしまって、その木構造毎に root となる要素を一つ定めておき、ある二つの要素が同じ集合にあるかどうかはそのそれぞれの root が一致するかどうかで決める。ここで、要素から辺をたどるときに結局 O(N) かかるのだけど一回たどった道は次回は O(1) で辿れるように辺情報を書き換えてやると均して見たときに時間計算量がほぼ O(1) になる。

```rust
fn root(x: usize) -> usize {
    if x != parent[x] {
        let p = parent[x];
        let r = root(p);
        parent[x] = r;
    }
    parent[x]
}
fn unite(x: usize, y: usize) {
    let mut x = root(x);
    let mut y = root(y);
    if x == y {
        return;
    }
    parent[x] = y
}
fn is_same_set(x: usize, y: usize) -> bool {
    root(x) == root(y)
}
```

### 街と道の完成
地形の完成判定は、地形それぞれにまだ空いている辺が何個あるかを持たせておき、それが 0 になったら完成という判定方法で行った。例えば右折タイルの街の地形だとこの値は最初 1 で、三角タイルの街だと 2 で十字の道の地形は 4 つともこの値が 1 になる。これを open side と呼ぶことにすると二つの地形 x, y のマージによってできる地形 z の open side は、マージによってそれぞれの地形の辺が 1 つ埋められるので、以下のように計算できる

```rust
z.open_side = x.open_side + y.open_side - 2;
```

ただし x と y が同じ地形のときは同じ地形内で辺が 2 つ埋められるので

```rust
z.open_side = x.open_side - 2;
```

### 街と道の得点計算
地形の得点計算はその地形の大きさみたいなものをもっておくだけで適当に計算できるのだけど、例えばカーブ系タイル 3 枚と交差点タイル 1 枚完成するような道は大きさが 5 になってしまったりするので、ユニークなタイルの数で計算しないといけない

### 修道院
やるだけなので省略

### 草原の得点計算
草原それぞれに (完成・未完成によらず) 接する街の id を全て持たせておく。適宜マージしながら管理して最終計算で完成した街の数を数えれば良い

## AI の詳細
TODO
